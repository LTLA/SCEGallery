[
["index.html", "The SingleCellExperiment Gallery Welcome", " The SingleCellExperiment Gallery 2020-09-14 Welcome One of the most important parts of single-cell data analysis is visualization. In fact, it could even be said that this is the most important part of the analysis. How else can we make Figure 1 of our Nature papers without some sweet, sweet \\(t\\)-SNEs? (Or UMAPs.) We need something to compete with the aesthetic appeal of a “representative” microscope image, after all. This book will showcase various methods for visualizing single-cell data from a SingleCellExperiment object. Each chapter focuses on a particular aspect of data visualization, starting with a brief analysis to set up the SingleCellExperiment before applying a range of plotting functions. Readers can then pick and choose their poison in a bake-off between visualization philosophies. All of the visualization packages presented here are available from the Bioconductor project. The major players are scater, a trusty old workhorse for working with SingleCellExperiment objects; dittoSeq, a more recent package focusing on colorblind-friendly visualizations; and scDataviz, yet another upstart offering plotting capabilities. If you’re a Bioconductor package developer and you think you can do better, bring it. (With a PR.) I’ll finish with a quote from Keats, for those of us unfortunate enough to have study poetry in high school: “Beauty is truth, truth beauty,”–that is all Ye know on earth, and all ye need to know. Pretty much sums up the field. "],
["plotting-reduced-dimensions.html", "Chapter 1 Plotting reduced dimensions 1.1 Foreword 1.2 Setting up the data 1.3 Visualizing with scater Session information", " Chapter 1 Plotting reduced dimensions .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 1.1 Foreword When one thinks of single-cell data analysis, one thinks of \\(t\\)-SNEs. (Or maybe UMAPs, for the younger folks.) Indeed, hardly a single-cell paper comes out these days without a \\(t\\)-SNE or UMAP plot in it somewhere. I would guess that their popularity stems from the entrancing illusion that a viewer is looking at “raw data”, unsullied by the authors’ interpretation. Indeed, I personally prefer \\(t\\)-SNEs as - with the right parameters - they can be made to look like histology images, while UMAPs look more like the aftermath of blowing your nose. But hey, to each their own. 1.2 Setting up the data Here we’ll use one of the many PBMC datasets generated by 10X Genomics (Zheng et al. 2017). One can only imagine how many times these PBMCs have been re-analyzed, surely there’s nothing we don’t know about these cells anymore. library(DropletTestFiles) fpath &lt;- getTestFile(file.path(&quot;tenx-3.0.0-pbmc_10k_protein_v3&quot;, &quot;1.0.0/filtered.tar.gz&quot;), prefix=TRUE) tmp &lt;- tempfile() untar(fpath, exdir=tmp) library(DropletUtils) sce &lt;- read10xCounts(file.path(tmp, &quot;filtered_feature_bc_matrix&quot;)) sce &lt;- splitAltExps(sce, rowData(sce)$Type) # splitting off the ADTs. sce ## class: SingleCellExperiment ## dim: 33538 7865 ## metadata(1): Samples ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames: NULL ## colData names(2): Sample Barcode ## reducedDimNames(0): ## altExpNames(1): Antibody Capture We slap together a quick-and-dirty analysis with some of the usual packages (Amezquita et al. 2020). Normally we would make some more diagnostic plots for each of these steps, but it would not do to distract from the star of the show in this chapter. library(scater) library(scran) library(scuttle) library(bluster) # Quality control on the mitochondrial content: qcstats &lt;- perCellQCMetrics(sce, subsets=list(Mito=grep(&quot;^MT-&quot;, rowData(sce)$Symbol))) discard &lt;- isOutlier(qcstats$subsets_Mito_percent, type=&quot;higher&quot;) sce &lt;- sce[,!discard] summary(discard) ## Mode FALSE TRUE ## logical 7569 296 # Normalization and feature selection: sce &lt;- logNormCounts(sce) dec &lt;- modelGeneVarByPoisson(sce) hvgs &lt;- getTopHVGs(dec, n=4000) # PCA and some clustering: set.seed(117) sce &lt;- runPCA(sce, subset_row=hvgs) colLabels(sce) &lt;- clusterRows(reducedDim(sce), NNGraphParam()) # Creating those sweet, sweet t-SNEs. set.seed(118) sce &lt;- runTSNE(sce, dimred=&quot;PCA&quot;) sce &lt;- runUMAP(sce, dimred=&quot;PCA&quot;) sce ## class: SingleCellExperiment ## dim: 33538 7569 ## metadata(1): Samples ## assays(2): counts logcounts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): ID Symbol Type ## colnames: NULL ## colData names(4): Sample Barcode sizeFactor label ## reducedDimNames(3): PCA TSNE UMAP ## altExpNames(1): Antibody Capture We can see that the dimensionality reduction results are tucked away in the reducedDims() of the sce object. If you want to get in on the action, you can pull out the reduced dimensions yourself for plotting: head(reducedDim(sce, &quot;TSNE&quot;)) ## [,1] [,2] ## [1,] 6.408 -22.65 ## [2,] 5.258 -20.71 ## [3,] 1.808 -20.09 ## [4,] 8.337 25.32 ## [5,] 5.944 29.59 ## [6,] -5.257 -31.47 1.3 Visualizing with scater We’ll start with the visualizations from the scater package (McCarthy et al. 2017). The plotTSNE() function creates ggplot objects with various aesthetics, as shown in Figure 1.1. Here, we have coloured each cell by its assigned label, throwing in the label name for good measure. plotTSNE(sce, colour_by=&quot;label&quot;, text_by=&quot;label&quot;) Figure 1.1: \\(t\\)-SNE coloured by the cluster label. Alternatively, we might color each cell by the expression of a particular gene, using the neon 80’s-throwback color scheme that is viridis (Figure 1.2). We set swap_rownames= to allow us to refer to genes using symbols rather than the more obtuse Ensembl identifiers. plotTSNE(sce, colour_by=&quot;CD3E&quot;, swap_rownames=&quot;Symbol&quot;, text_by=&quot;label&quot;, text_colour=&quot;red&quot;) Figure 1.2: \\(t\\)-SNE coloured by the expression of CD3E. This function (and its sister plotUMAP()) use the same plotReducedDim() function under the hood. We can generate plots for any dimensionality reduction result in sce by calling plotReducedDim() directly, passing in the name of the result that we wish to visualize (Figure 1.3). plotReducedDim(sce, &quot;UMAP&quot;, colour_by=&quot;label&quot;, text_by=&quot;label&quot;) Figure 1.3: UMAP coloured by the cluster label. And of course, this is all ggplot-based, so you can just add on your own layers to customize the aesthetics. Don’t like viridis? (Does anybody? Ho ho ho.) You can swap it out with a color scale of your choice using the relevant ggplot2 functions, as shown in Figure 1.4 with a grey-orange gradient for CD3E expression. plotUMAP(sce, colour_by=&quot;CD3E&quot;, swap_rownames=&quot;Symbol&quot;) + scale_color_gradient(low=&quot;grey&quot;, high=&quot;orange&quot;) Figure 1.4: UMAP coloured by the expression of CD3E. In fact, you can tell plotTSNE() and plotUMAP() to carry over any colData() field from the SingleCellExperiment. These fields are inserted into the data.frame and can be used in any ggplot2-compatible function. In Figure 1.5, we bin each cell based on its size factor to create the category field, and we use those bins for faceting the plot generated by plotTSNE(). sce$category &lt;- cut(log(sizeFactors(sce)), 3) plotTSNE(sce, colour_by=&quot;label&quot;, other_fields=&quot;category&quot;) + facet_wrap(&#39;category&#39;) Figure 1.5: \\(t\\)-SNE coloured by the cluster identity and faceted by the log-size factor after binning. While most customization can be performed by adding further ggplot-related layers, we can also tinker with other aesthetic parameters in the plotTSNE() call. For example, we change the point size and axis labels while also removing the legend in Figure ??. Further options can be found by following the breadcrumbs in the documentation for ?plotTSNE. plotTSNE(sce, colour_by=&quot;label&quot;, point_size=0.25, add_legend=FALSE, label_format=&quot;%s dimension %i&quot;) I could go on, but I won’t. Session information View session info R version 4.0.2 Patched (2020-09-10 r79182) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.1 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-openmp/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] bluster_0.99.1 scuttle_0.99.13 [3] scran_1.17.16 scater_1.17.4 [5] ggplot2_3.3.2 DropletUtils_1.9.11 [7] SingleCellExperiment_1.11.6 SummarizedExperiment_1.19.6 [9] DelayedArray_0.15.7 matrixStats_0.56.0 [11] Matrix_1.2-18 Biobase_2.49.1 [13] GenomicRanges_1.41.6 GenomeInfoDb_1.25.11 [15] IRanges_2.23.10 S4Vectors_0.27.12 [17] BiocGenerics_0.35.4 DropletTestFiles_0.99.5 [19] BiocStyle_2.17.0 BiocManager_1.30.10 loaded via a namespace (and not attached): [1] Rtsne_0.15 ggbeeswarm_0.6.0 [3] colorspace_1.4-1 ellipsis_0.3.1 [5] XVector_0.29.3 BiocNeighbors_1.7.0 [7] farver_2.0.3 bit64_4.0.5 [9] RSpectra_0.16-0 interactiveDisplayBase_1.27.5 [11] AnnotationDbi_1.51.3 codetools_0.2-16 [13] R.methodsS3_1.8.1 knitr_1.29 [15] dbplyr_1.4.4 R.oo_1.24.0 [17] rebook_0.99.5 graph_1.67.1 [19] uwot_0.1.8 shiny_1.5.0 [21] HDF5Array_1.17.3 compiler_4.0.2 [23] httr_1.4.2 dqrng_0.2.1 [25] assertthat_0.2.1 fastmap_1.0.1 [27] limma_3.45.14 later_1.1.0.1 [29] BiocSingular_1.5.0 htmltools_0.5.0 [31] tools_4.0.2 rsvd_1.0.3 [33] igraph_1.2.5 gtable_0.3.0 [35] glue_1.4.2 GenomeInfoDbData_1.2.3 [37] dplyr_1.0.2 rappdirs_0.3.1 [39] Rcpp_1.0.5 vctrs_0.3.4 [41] rhdf5filters_1.1.2 ExperimentHub_1.15.3 [43] DelayedMatrixStats_1.11.1 xfun_0.17 [45] stringr_1.4.0 ps_1.3.4 [47] mime_0.9 lifecycle_0.2.0 [49] irlba_2.3.3 statmod_1.4.34 [51] XML_3.99-0.5 AnnotationHub_2.21.5 [53] edgeR_3.31.4 zlibbioc_1.35.0 [55] scales_1.1.1 promises_1.1.1 [57] rhdf5_2.33.7 yaml_2.2.1 [59] curl_4.3 memoise_1.1.0 [61] gridExtra_2.3 stringi_1.5.3 [63] RSQLite_2.2.0 highr_0.8 [65] BiocVersion_3.12.0 BiocParallel_1.23.2 [67] rlang_0.4.7 pkgconfig_2.0.3 [69] bitops_1.0-6 evaluate_0.14 [71] lattice_0.20-41 purrr_0.3.4 [73] Rhdf5lib_1.11.3 labeling_0.3 [75] CodeDepends_0.6.5 bit_4.0.4 [77] processx_3.4.4 tidyselect_1.1.0 [79] RcppAnnoy_0.0.16 magrittr_1.5 [81] bookdown_0.20 R6_2.4.1 [83] generics_0.0.2 DBI_1.1.0 [85] pillar_1.4.6 withr_2.2.0 [87] RCurl_1.98-1.2 tibble_3.0.3 [89] crayon_1.3.4 BiocFileCache_1.13.1 [91] rmarkdown_2.3 viridis_0.5.1 [93] locfit_1.5-9.4 grid_4.0.2 [95] blob_1.2.1 callr_3.4.4 [97] digest_0.6.25 xtable_1.8-4 [99] httpuv_1.5.4 R.utils_2.10.1 [101] munsell_0.5.0 beeswarm_0.2.3 [103] viridisLite_0.3.0 vipor_0.4.5 Bibliography "],
["plotting-gene-expression.html", "Chapter 2 Plotting gene expression 2.1 Foreword 2.2 Setting up the dataset 2.3 Visualizing with scater Session information", " Chapter 2 Plotting gene expression .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 2.1 Foreword If “CSI: Miami” has taught me anything, it’s that Miami is made of palm trees. On the sidewalks, in the parks, on people’s lawns: they’re basically weeds over there. I mention this because I get a strange sense of déjà vu when I read single-cell papers: just replace the palm trees with violin plots and boom! - you’re in a bioinformatics version of South Beach. Admittedly, violin plots do provide a compact yet informative visualization of the distribution of expression values, serving as a satisfactory, possibly even decent compromise between boxplots and histograms. (Yes, I do know about ridgeline plots. No, don’t try to sell them to me.) This chapter will show you how to contribute to the violin plot overdose in the single-cell field. This chapter’s rated R… for excessive violins. (•_•) / ( •_•)&gt;⌐■-■ / (⌐■_■) YEAAAAAHH! 2.2 Setting up the dataset At one point, it was highly fashionable to perform scRNA-seq on the pancreas. After all, it’s a highly heterogeneous tissue with clear differences between cell types, which makes it easy to use to generate some impressive-looking plots. Following this example, we’ll be using a pancreas dataset from Segerstolpe et al. (2016) for our demonstrations here. library(scRNAseq) sce &lt;- SegerstolpePancreasData() We need to generate normalized log-expression values for high-quality cells. As it happens, the authors provided some indications of which cells were low-quality, which we combine with our own filtering (see the other book for details). low.qual &lt;- sce$`single cell well quality` == &quot;low quality cell&quot; library(scater) stats &lt;- perCellQCMetrics(sce) qc &lt;- quickPerCellQC(stats, percent_subsets=&quot;altexps_ERCC_percent&quot;, batch=sce$individual, subset=!sce$individual %in% c(&quot;HP1504901&quot;, &quot;HP1509101&quot;)) sce &lt;- sce[,!(qc$discard | low.qual)] sce &lt;- logNormCounts(sce) Happily enough, the authors also provided cell type labels (cell type) and disease status (disease) for each individual. We’ll be using these to spice up some of the visualizations below. 2.3 Visualizing with scater When one thinks of the pancreas, one thinks of insulin, and so Figure 2.1 shows the distribution of INS expression in each cell type. We call scater’s plotExpression() function (McCarthy et al. 2017) with features=\"INS\", which extracts the log-expression values of INS from sce; along with x=\"cell type\", to specify that we want the cell type identities on the x-axis. Again, the output of this function is a ggplot object so we can add more layers to customize the plot’s appearance - in this case, we’ve flipped the coordinates to improve the label visibility. library(ggplot2) plotExpression(sce, features=&quot;INS&quot;, x=&quot;cell type&quot;, colour_by=&quot;cell type&quot;) + coord_flip() Figure 2.1: Distribution of INS expression in each cell type of the Segerstolpe dataset. Each point represents a cell and is colored by its assigned cell type for an extra touch of aesthetics. It might seem redundant to color by the same variable on the axis, but this can be particularly useful in more complex plots. Color-coding in Figure 2.2 allows us to easily compare expression across the same cell type in different donors. We also add some grid lines to make it easier to compare across facets. plotExpression(sce, features=&quot;INS&quot;, x=&quot;cell type&quot;, colour_by=&quot;cell type&quot;, other_fields=&quot;individual&quot;) + coord_flip() + facet_wrap(~individual) + theme(panel.grid.major.x = element_line(size=.1, color=&quot;grey&quot;)) Figure 2.2: Distribution of INS expression in each cell type for each donor of the Segerstolpe dataset. Each point represents a cell and is colored by its assigned cell type, while each facet contains all cells from a particular donor. More simply, we could color by any other interesting factor in colData(sce), such as the disease status (Figure 2.3): plotExpression(sce, features=&quot;INS&quot;, x=&quot;cell type&quot;, colour_by=&quot;disease&quot;) + coord_flip() Figure 2.3: Distribution of INS expression in each cell type of the Segerstolpe dataset. Each point represents a cell and is colored by the disease status of its donor of origin. Or possibly a continuous variable such as size factor for each cell (Figure 2.4). Now, the colData() does contain a \"sizeFactor\" variable but we would like to color by the log-transformed size factor to improve resolution among low size factors. This is easily achieved by log-transforming the size factors ourselves and then passing them to plotExpression() inside a DataFrame(); this tells the function to use the supplied values directly. (An even more succinct method is to pass it inside an I() call, but this means we won’t be able to insert the \"LogSizeFactor\" name in the legend.) log.sf &lt;- DataFrame(LogSizeFactors=log2(sizeFactors(sce))) plotExpression(sce, features=&quot;INS&quot;, x=&quot;cell type&quot;, colour_by=log.sf) + coord_flip() Figure 2.4: Distribution of INS expression in each cell type of the Segerstolpe dataset. Each point represents a cell and is colored by its log-transformed size factor. Alternatively, we could color by the cell type while having the log-size factors on one of the axes (Figure 2.5). plotExpression() is smart enough to detect the type of the variables on the axes to generate an appropriate plot - in this case, switching from those violins to a scatter plot. plotExpression(sce, features=&quot;INS&quot;, x=log.sf, colour_by=&quot;cell type&quot;) Figure 2.5: INS expression against the log-size factor in the Segerstolpe dataset. Each point represents a cell and is colored by its assigned cell type. The same procedure also works with other genes. For example, we can plot INS against the other famous product of the pancreas, GCG (Figure 2.6). plotExpression(sce, features=&quot;INS&quot;, x=&quot;GCG&quot;, colour_by=&quot;cell type&quot;) Figure 2.6: INS expression against GCG expression in the Segerstolpe dataset. Each point represents a cell and is colored by its assigned cell type. Speaking of other genes, we can also pass a vector of gene names in features=. When x= is also specified, this will create one facet per gene (Figure 2.7). plotExpression(sce, features=c(&quot;INS&quot;, &quot;GCG&quot;, &quot;PPY&quot;, &quot;SST&quot;), x=&quot;cell type&quot;, colour_by=&quot;cell type&quot;) + coord_flip() Figure 2.7: Distribution of the expression of various pancreas-related marker genes in the Segerstolpe dataset. Each point represents a cell and is colored by its assigned cell type, while each facet corresponds to a single marker gene. Session information View session info R version 4.0.2 Patched (2020-09-10 r79182) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.1 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-openmp/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] parallel stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] scater_1.17.4 ggplot2_3.3.2 [3] scRNAseq_2.3.13 SingleCellExperiment_1.11.6 [5] SummarizedExperiment_1.19.6 DelayedArray_0.15.7 [7] matrixStats_0.56.0 Matrix_1.2-18 [9] Biobase_2.49.1 GenomicRanges_1.41.6 [11] GenomeInfoDb_1.25.11 IRanges_2.23.10 [13] S4Vectors_0.27.12 BiocGenerics_0.35.4 [15] BiocStyle_2.17.0 BiocManager_1.30.10 loaded via a namespace (and not attached): [1] bitops_1.0-6 bit64_4.0.5 [3] httr_1.4.2 tools_4.0.2 [5] R6_2.4.1 irlba_2.3.3 [7] vipor_0.4.5 DBI_1.1.0 [9] colorspace_1.4-1 withr_2.2.0 [11] gridExtra_2.3 tidyselect_1.1.0 [13] processx_3.4.4 bit_4.0.4 [15] curl_4.3 compiler_4.0.2 [17] rebook_0.99.5 graph_1.67.1 [19] BiocNeighbors_1.7.0 labeling_0.3 [21] bookdown_0.20 scales_1.1.1 [23] callr_3.4.4 rappdirs_0.3.1 [25] stringr_1.4.0 digest_0.6.25 [27] rmarkdown_2.3 XVector_0.29.3 [29] pkgconfig_2.0.3 htmltools_0.5.0 [31] highr_0.8 dbplyr_1.4.4 [33] fastmap_1.0.1 rlang_0.4.7 [35] RSQLite_2.2.0 shiny_1.5.0 [37] DelayedMatrixStats_1.11.1 farver_2.0.3 [39] generics_0.0.2 BiocParallel_1.23.2 [41] dplyr_1.0.2 RCurl_1.98-1.2 [43] magrittr_1.5 BiocSingular_1.5.0 [45] GenomeInfoDbData_1.2.3 scuttle_0.99.13 [47] Rcpp_1.0.5 ggbeeswarm_0.6.0 [49] munsell_0.5.0 viridis_0.5.1 [51] lifecycle_0.2.0 stringi_1.5.3 [53] yaml_2.2.1 zlibbioc_1.35.0 [55] BiocFileCache_1.13.1 AnnotationHub_2.21.5 [57] grid_4.0.2 blob_1.2.1 [59] promises_1.1.1 ExperimentHub_1.15.3 [61] crayon_1.3.4 lattice_0.20-41 [63] CodeDepends_0.6.5 knitr_1.29 [65] ps_1.3.4 pillar_1.4.6 [67] codetools_0.2-16 XML_3.99-0.5 [69] glue_1.4.2 BiocVersion_3.12.0 [71] evaluate_0.14 vctrs_0.3.4 [73] httpuv_1.5.4 gtable_0.3.0 [75] purrr_0.3.4 assertthat_0.2.1 [77] xfun_0.17 rsvd_1.0.3 [79] mime_0.9 xtable_1.8-4 [81] later_1.1.0.1 viridisLite_0.3.0 [83] tibble_3.0.3 AnnotationDbi_1.51.3 [85] beeswarm_0.2.3 memoise_1.1.0 [87] ellipsis_0.3.1 interactiveDisplayBase_1.27.5 Bibliography "],
["bibliography.html", "Chapter 3 Bibliography", " Chapter 3 Bibliography "]
]
